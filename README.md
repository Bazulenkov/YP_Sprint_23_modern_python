# YP_Sprint_23_modern_python
Примеры с кодом к вебинару для Яндекс.Практикум. 23й спринт (2ой спринт по FastAPI)




# TypeVar

`T = TypeVar("T")`  # T – произвольный тип без ограничений

`T = TypeVar("T", int, float)`  # T – тип связанный только с типами int и float

`T = TypeVar("T", bound=Geom)`  # T – тип класса Geom или его дочернего класса


---

# Generics

это механизм для создания классов, которые могут работать с разными типами данных, сохраняя при этом строгую типизацию.


Старый синтаксис `class Stack(Generic[T]): pass`
для python=^3.12   `class Stack[T]: pass`


https://mypy.readthedocs.io/en/stable/generics.html

---
#### Как работает `Generic[T]`

1. Указывая `Generic[T]` в качестве одного из родителей класса, мы объявляем, что класс является дженериком
2. Внутри этого класса можно использовать `T` как тип данных (как видно в поле `data: T`)
3. При создании конкретного экземпляра класса, `T` заменяется на указанный тип

---

### Преимущества такого подхода

1. **Повторное использование кода**
2. **Типовая безопасность**
3. **Подсказки IDE**
4. **Самодокументирование**:


Без дженериков вам пришлось бы:

1. Создать отдельный класс для каждого типа данных (например, `UserResponse`, `ProductResponse`) или
2. Использовать динамическую типизацию (например, `data: Any`), что менее безопасно и информативно

---

# callback (функция обратного вызова)

это функция, которая передаётся в другую функцию в качестве аргумента и вызывается внутри этой функции для выполнения определённой задачи.

## Основные характеристики callback функций:

1. **Передача функции как параметра** — вы передаёте функцию в качестве аргумента другой функции
2. **Отложенное выполнение** — callback функция не выполняется сразу, а вызывается в определённый момент внутри основной функции
3. **Инверсия контроля** — вы передаёте часть логики программы "наружу", давая возможность внешнему коду определять, что должно произойти

---

## Практические применения callback функций:

1. **Обработка асинхронных операций**
2. **Обработка событий**
3. **Делегирование части логики**
4. **Создание гибких и переиспользуемых компонентов**

Callback функции делают код более гибким и модульным, позволяя отделить общую логику от специфичной и легко изменять поведение программы без изменения основной структуры кода.

---

### Абстрактные классы Abstract Base Classes  (ABCs)

- Не могут быть инстанцированы напрямую
- Наследники должны реализовать все абстрактные методы
- Обеспечивают проверку соответствия интерфейсу в момент создания класса


[ABCMeta - документация](https://docs.python.org/3/library/abc.html#abc.ABCMeta) - https://docs.python.org/3/library/abc.html#abc.ABCMeta

---
## Protocol
проверяeт следует ли какой-то класс или объект заранее определенному интерфейсу.


- Реализуют структурную типизацию (утиная типизация, duck typing)
- Класс соответствует протоколу, если у него реализованы все необходимые методы
- Не требуют явного наследования
- Используются преимущественно для статической типизации и проверок типов

Паттерн програмирования - "интерфейс".

---

# Инвариантность
# Ковариантность
# Контравариантность

---
## Инвариантность (Invariance)

означает, что типы должны точно совпадать без какой-либо иерархии наследования.

- При инвариантности, если `A` является подтипом `B`, то контейнер типа `Container[A]` **не является** ни подтипом, ни супертипом `Container[B]`.
- Это наиболее строгое отношение между типами.

---
## Ковариантность (Covariance)

позволяет использовать более конкретный тип там, где ожидается более общий тип.

- Если `A` является подтипом `B`, то `Container[A]` является подтипом `Container[B]`.
- Ковариантность обычно безопасна для контейнеров, которые предоставляют доступ только для чтения (immutable), так как это гарантирует, что мы не сможем вставить несовместимые типы в контейнер.

---
## Контравариантность (Contravariance)

противоположность ковариантности. Она позволяет использовать более общий тип там, где ожидается более конкретный.

- Если `A` является подтипом `B`, то `Container[B]` является подтипом `Container[A]` (обратная иерархия).
- Это обычно безопасно для контейнеров, которые только потребляют значения (например, только для записи).

---
#### Понимание контравариантности функций:

С точки зрения логической безопасности типов, функция, ожидающая более конкретный тип (например, `str`), может использоваться там, где требуется функция, принимающая более общий тип (например, `object`). Это потому, что:

1. Если функция `f` может обрабатывать любой объект (`object`),
2. А вызывается она только со строками (`str`),
3. То функция `g`, которая специализируется только на строках, справится с этой задачей.

---

## Наглядная визуализация иерархии совместимости:

```

object > Animal > Dog  (иерархия типов)
```

Для контравариантных компараторов иерархия меняется на противоположную:

```

Comparator[object] < Comparator[Animal] < Comparator[Dog]  (иерархия компараторов)
```

Это означает, что `Comparator[object]` может быть использован везде, где требуется `Comparator[Dog]`, но не наоборот.

---
## Практическая польза

Такая типизация позволяет:

1. **Повторно использовать общие реализации** — вместо создания отдельных компараторов для каждого типа можно написать один общий
2. **Обеспечить безопасность типов** — статические анализаторы кода могут проверить правильность использования компараторов
3. **Улучшить читаемость кода** — аннотация явно показывает, какой тип объектов должен уметь сравнивать компаратор

В современной разработке такой подход активно используется для создания гибких, расширяемых и типобезопасных API.

---

Вопросы???
